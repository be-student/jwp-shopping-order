# 2단계 기능 목록 작성

- [x] swagger 적용

- [x] 테이블 설계
- [x] 기존 cart 에 어울리지 않는 기능들 도메인별로 분리

- [ ] 도메인 설계
    - [ ] 회원
    - [ ] 상품
    - [ ] 쿠폰
    - [ ] 장바구니
    -
- API 설계
    - 쿠폰
        - [ ] 모든 쿠폰을 조회할 수 있다
        - [ ] 멤버가 가지고 있는 쿠폰을 조회할 수 있다
        - [ ] 멤버가 쿠폰을 발급 받을 수 있다
    - 주문
        - [ ] 사용자는 장바구니에 담긴 상품을 주문할 수 있다
        - [ ] 사용자는 주문 내역을 조회할 수 있다
        - [ ] 특정 주문의 상세 정보를 조회할 수 있다

# 테이블 설계

![erd](./docs/erd.png)

## 주문

주문 테이블에서 상품을 직접 PK 로 참조하지 않는 이유는 도메인별로 특징에 맞는 db 를 사용할 수 있다는 가정을 가지고 진행했습니다

주문이라는 서비스가 나중에 다른 프로젝트로 분리되면, 주문 테이블에서 상품을 직접 참조하는 것은 불필요한 의존성을 만들게 됩니다

장바구니 상품에서 그냥 ID 만을 참조하지 않는 이유는, 장바구니에 담긴 상품이 삭제되더라도 주문 내역에는 남아있어야 하기 때문입니다

장바구니 상품이 변경되면, 장바구니에는 영향을 주지 않고, 주문시, 예외를 발생시키기 위해서 입니다

예시) 짜장면 3000원을 담았는데, 짬뽕 5000원으로 변경된 경우, 주문 내역이 짬뽕으로 변경되면 이상하다고 생각했습니다

## 의식적인 지름길

### UseCase 마다 컨트롤러, 서비스 분리, UseCase 인터페이스 작성을 하지 않았습니다

규모가 너무 작아서, 그정도까지 필요 없어 보였습니다

### 컨트롤러에서 service 레이어의 dto 를 그대로 requestBody 로 받습니다

컨트롤러에서 새로운 dto 를 사용하게 되면, 그만큼의 복잡도가 늘어나서 하지 않았습니다

### service 에서 도메인을 반환합니다

service 에서 dto 를 반환하게 되면, 그만큼의 복잡도가 늘어나서 하지 않았습니다

# 질문

### Member ArgumentResolver 를 어디다 두는게 맞나요?

서로 다른 환경에서 사용한다고 생각하면, member 테이블이 없을테니, 직접 db 조회를 해오는 것은 힘들 것 같아 보입니다  
coupon 과, order 에서 member 의 정보가 맞는지 검사를 해야하니, argumentResolver 가 필연적으로 중복 구현이 되는데요  
이정도는 어쩔 수 없는 중복인가요?

### 도메인별 클래스 네임

쿠폰에도 멤버가 필요하고, 카트에도 member 가 필요합니다  
쿠폰 도메인에서는 네이밍상 Member 가 적절하지만, Cart 에서는 Buyer 라는 네이밍이 더 적합해보이는데요  
서로 다른 도메인에 이름을 통일시키는 방향으로 작성하는 것이 좋은지, 아니면 도메인별 적절한 네이밍을 사용하는 것이 더 권장되는지 궁금합니다
